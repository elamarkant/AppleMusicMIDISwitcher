import Foundation
import CoreAudio
import CoreMIDI
import AudioToolbox

class AppleMusicMIDIController {
    private var midiClient: MIDIClientRef = 0
    private var outputPort: MIDIPortRef = 0
    private var currentSampleRate: Float64 = 0
    private var currentBitDepth: Int = 0
    private var timer: Timer?
    private var selectedDeviceID: AudioDeviceID?
    
    private struct AudioDeviceInfo {
        let id: AudioDeviceID
        let inputChannels: Int
        let outputChannels: Int
    }
    
    init() {
        setupMIDI()
        selectAudioDevice()
        startMonitoring()
    }
    
    deinit {
        cleanup()
    }
    
    private func setupMIDI() {
        let status = MIDIClientCreate("AppleMusicMIDIController" as CFString, nil, nil, &midiClient)
        if status != noErr {
            print("‚ùå ÂàõÂª∫ MIDI ÂÆ¢Êà∑Á´ØÂ§±Ë¥•: \(status)")
            return
        }
        
        let portStatus = MIDIOutputPortCreate(midiClient, "Output Port" as CFString, &outputPort)
        if portStatus != noErr {
            print("‚ùå ÂàõÂª∫ËæìÂá∫Á´ØÂè£Â§±Ë¥•: \(portStatus)")
            return
        }
        
        print("‚úÖ MIDI ËÆæÁΩÆÂÆåÊàê")
    }
    
    private func selectAudioDevice() {
        let devices = getAllAudioDevices()
        
        if devices.isEmpty {
            print("‚ùå Êú™ÊâæÂà∞‰ªª‰ΩïÈü≥È¢ëËÆæÂ§á")
            return
        }
        
        print("\nüîç Êâ´ÊèèÂà∞‰ª•‰∏ãÈü≥È¢ëËÆæÂ§á:")
        print(String(repeating: "=", count: 50))
        
        for (index, device) in devices.enumerated() {
            let deviceName = getDeviceName(deviceID: device.id) ?? "Êú™Áü•ËÆæÂ§á"
            let sampleRate = getCurrentSampleRate(deviceID: device.id)
            let bitDepth = getCurrentBitDepth(deviceID: device.id)
            
            print("\(index + 1). \(deviceName)")
            print("   ËÆæÂ§áID: \(device.id)")
            print("   ÂΩìÂâçÈááÊ†∑Áéá: \(sampleRate) Hz")
            print("   ÂΩìÂâç‰ΩçÊ∑±Â∫¶: \(bitDepth) bit")
            print("   ËæìÂÖ•ÈÄöÈÅì: \(device.inputChannels), ËæìÂá∫ÈÄöÈÅì: \(device.outputChannels)")
            print("")
        }
        
        print("ËØ∑ÈÄâÊã©Ë¶ÅËá™Âä®Êõ¥ÊîπËÆæÁΩÆÁöÑËÆæÂ§á (ËæìÂÖ•Â∫èÂè∑ 1-\(devices.count)):")
        
        if let input = readLine(), let choice = Int(input), choice >= 1 && choice <= devices.count {
            selectedDeviceID = devices[choice - 1].id
            let deviceName = getDeviceName(deviceID: selectedDeviceID!) ?? "Êú™Áü•ËÆæÂ§á"
            print("‚úÖ Â∑≤ÈÄâÊã©ËÆæÂ§á: \(deviceName)")
        } else {
            print("‚ùå Êó†ÊïàÈÄâÊã©ÔºåÂ∞Ü‰ΩøÁî®ÈªòËÆ§ËæìÂá∫ËÆæÂ§á")
            selectedDeviceID = getDefaultOutputDevice()
        }
    }
    
    private func getAllAudioDevices() -> [AudioDeviceInfo] {
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDevices,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var size: UInt32 = 0
        var status = AudioObjectGetPropertyDataSize(
            AudioObjectID(kAudioObjectSystemObject),
            &address,
            0,
            nil,
            &size
        )
        
        guard status == noErr else { return [] }
        
        let deviceCount = Int(size) / MemoryLayout<AudioDeviceID>.size
        var deviceIDs = Array<AudioDeviceID>(repeating: 0, count: deviceCount)
        
        status = AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &address,
            0,
            nil,
            &size,
            &deviceIDs
        )
        
        guard status == noErr else { return [] }
        
        var devices: [AudioDeviceInfo] = []
        
        for deviceID in deviceIDs {
            let inputChannels = getChannelCount(deviceID: deviceID, scope: kAudioDevicePropertyScopeInput)
            let outputChannels = getChannelCount(deviceID: deviceID, scope: kAudioDevicePropertyScopeOutput)
            
            // Âè™ÂåÖÂê´ÊúâËæìÂá∫ÈÄöÈÅìÁöÑËÆæÂ§á
            if outputChannels > 0 {
                devices.append(AudioDeviceInfo(
                    id: deviceID,
                    inputChannels: inputChannels,
                    outputChannels: outputChannels
                ))
            }
        }
        
        return devices
    }
    
    private func getChannelCount(deviceID: AudioDeviceID, scope: AudioObjectPropertyScope) -> Int {
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyStreamConfiguration,
            mScope: scope,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var size: UInt32 = 0
        let status = AudioObjectGetPropertyDataSize(deviceID, &address, 0, nil, &size)
        guard status == noErr else { return 0 }
        
        let bufferList = UnsafeMutablePointer<AudioBufferList>.allocate(capacity: 1)
        defer { bufferList.deallocate() }
        
        let getStatus = AudioObjectGetPropertyData(deviceID, &address, 0, nil, &size, bufferList)
        guard getStatus == noErr else { return 0 }
        
        var channelCount = 0
        let bufferCount = Int(bufferList.pointee.mNumberBuffers)
        
        withUnsafePointer(to: &bufferList.pointee.mBuffers) { buffersPtr in
            let buffers = UnsafeBufferPointer(start: buffersPtr, count: bufferCount)
            for buffer in buffers {
                channelCount += Int(buffer.mNumberChannels)
            }
        }
        
        return channelCount
    }
    
    private func getDeviceName(deviceID: AudioDeviceID) -> String? {
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyDeviceNameCFString,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var size: UInt32 = 0
        var status = AudioObjectGetPropertyDataSize(deviceID, &address, 0, nil, &size)
        guard status == noErr else { return nil }
        
        var name: Unmanaged<CFString>?
        status = AudioObjectGetPropertyData(deviceID, &address, 0, nil, &size, &name)
        guard status == noErr, let deviceName = name?.takeRetainedValue() else { return nil }
        
        return deviceName as String
    }
    
    private func getCurrentSampleRate(deviceID: AudioDeviceID) -> Float64 {
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyNominalSampleRate,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var sampleRate: Float64 = 0
        var size = UInt32(MemoryLayout<Float64>.size)
        
        let status = AudioObjectGetPropertyData(deviceID, &address, 0, nil, &size, &sampleRate)
        return status == noErr ? sampleRate : 0
    }
    
    private func getCurrentBitDepth(deviceID: AudioDeviceID) -> Int {
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyStreamFormat,
            mScope: kAudioObjectPropertyScopeOutput,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var format = AudioStreamBasicDescription()
        var size = UInt32(MemoryLayout<AudioStreamBasicDescription>.size)
        
        let status = AudioObjectGetPropertyData(deviceID, &address, 0, nil, &size, &format)
        return status == noErr ? Int(format.mBitsPerChannel) : 0
    }
    
    private func getDefaultOutputDevice() -> AudioDeviceID? {
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultOutputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var deviceID: AudioDeviceID = 0
        var size = UInt32(MemoryLayout<AudioDeviceID>.size)
        
        let status = AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &address,
            0,
            nil,
            &size,
            &deviceID
        )
        
        return status == noErr ? deviceID : nil
    }
    
    private func startMonitoring() {
        guard selectedDeviceID != nil else {
            print("‚ùå Êú™ÈÄâÊã©ÊúâÊïàËÆæÂ§áÔºåÊó†Ê≥ïÂºÄÂßãÁõëÊéß")
            return
        }
        
        print("üéµ ÂºÄÂßãÁõëÊéß Apple Music Èü≥È¢ëÊ†ºÂºèÂèòÂåñ...")
        
        // ÊØè5ÁßíÊ£ÄÊü•‰∏ÄÊ¨°
        timer = Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { _ in
            self.checkAppleMusicLogs()
        }
        
        // Á´ãÂç≥ÊâßË°å‰∏ÄÊ¨°
        checkAppleMusicLogs()
    }
    
    private func checkAppleMusicLogs() {
        let task = Process()
        task.launchPath = "/usr/bin/log"
        task.arguments = [
            "show",
            "--predicate", "subsystem contains \"com.apple.Music\" AND message contains \"asbdSampleRate\"",
            "--last", "10s",
            "--style", "compact"
        ]
        
        let pipe = Pipe()
        task.standardOutput = pipe
        task.standardError = pipe
        
        do {
            try task.run()
            task.waitUntilExit()
            
            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            if let output = String(data: data, encoding: .utf8) {
                parseLogOutput(output)
            }
        } catch {
            print("‚ùå ÊâßË°åÊó•ÂøóÂëΩ‰ª§Â§±Ë¥•: \(error)")
        }
    }
    
    private func parseLogOutput(_ output: String) {
        let lines = output.components(separatedBy: .newlines)
        
        for line in lines {
            if line.contains("asbdSampleRate") && line.contains("sdBitDepth") {
                if let audioInfo = extractAudioInfo(from: line) {
                    let sampleRate = audioInfo.sampleRate
                    let bitDepth = audioInfo.bitDepth
                    
                    // Ê£ÄÊü•ÊòØÂê¶ÊúâÂèòÂåñ
                    if sampleRate != currentSampleRate || bitDepth != currentBitDepth {
                        print("üîÑ Ê£ÄÊµãÂà∞Èü≥È¢ëÊ†ºÂºèÂèòÂåñ:")
                        print("   ÈááÊ†∑Áéá: \(currentSampleRate) Hz ‚Üí \(sampleRate) Hz")
                        print("   ‰ΩçÊ∑±Â∫¶: \(currentBitDepth) bit ‚Üí \(bitDepth) bit")
                        
                        currentSampleRate = sampleRate
                        currentBitDepth = bitDepth
                        
                        updateMIDISettings(sampleRate: sampleRate, bitDepth: bitDepth)
                    }
                }
            }
        }
    }
    
    private func extractAudioInfo(from logLine: String) -> (sampleRate: Float64, bitDepth: Int)? {
        // Ëß£Êûê asbdSampleRate = 96.0 kHz
        let sampleRatePattern = #"asbdSampleRate = ([0-9.]+) kHz"#
        let bitDepthPattern = #"sdBitDepth = ([0-9]+) bit"#
        
        guard let sampleRateRegex = try? NSRegularExpression(pattern: sampleRatePattern),
              let bitDepthRegex = try? NSRegularExpression(pattern: bitDepthPattern) else {
            return nil
        }
        
        let range = NSRange(location: 0, length: logLine.utf16.count)
        
        // ÊèêÂèñÈááÊ†∑Áéá
        guard let sampleRateMatch = sampleRateRegex.firstMatch(in: logLine, range: range),
              let sampleRateRange = Range(sampleRateMatch.range(at: 1), in: logLine),
              let sampleRateValue = Float64(logLine[sampleRateRange]) else {
            return nil
        }
        
        // ÊèêÂèñ‰ΩçÊ∑±Â∫¶
        guard let bitDepthMatch = bitDepthRegex.firstMatch(in: logLine, range: range),
              let bitDepthRange = Range(bitDepthMatch.range(at: 1), in: logLine),
              let bitDepthValue = Int(logLine[bitDepthRange]) else {
            return nil
        }
        
        // ËΩ¨Êç¢ kHz Âà∞ Hz
        let sampleRateHz = sampleRateValue * 1000
        
        return (sampleRate: sampleRateHz, bitDepth: bitDepthValue)
    }
    
    private func updateMIDISettings(sampleRate: Float64, bitDepth: Int) {
        print("üéõÔ∏è Êõ¥Êñ∞ MIDI ËÆæÁΩÆ...")
        
        guard let deviceID = selectedDeviceID else {
            print("‚ùå Êú™ÈÄâÊã©ÊúâÊïàËÆæÂ§á")
            return
        }
        
        let deviceName = getDeviceName(deviceID: deviceID) ?? "Êú™Áü•ËÆæÂ§á"
        print("üéØ ÁõÆÊ†áËÆæÂ§á: \(deviceName)")
        
        // Ëé∑ÂèñÂΩìÂâçËÆæÁΩÆÁî®‰∫éÊØîËæÉ
        let currentSampleRate = getCurrentSampleRate(deviceID: deviceID)
        let currentBitDepth = getCurrentBitDepth(deviceID: deviceID)
        
        print("üìä ÂΩìÂâçËÆæÁΩÆ: \(currentSampleRate) Hz, \(currentBitDepth) bit")
        print("üéØ ÁõÆÊ†áËÆæÁΩÆ: \(sampleRate) Hz, \(bitDepth) bit")
        
        var successCount = 0
        var totalOperations = 0
        
        // ËÆæÁΩÆÈááÊ†∑Áéá
        if abs(currentSampleRate - sampleRate) > 1.0 {
            totalOperations += 1
            if setAudioDeviceSampleRate(deviceID: deviceID, sampleRate: sampleRate) {
                print("‚úÖ MIDI ÈááÊ†∑ÁéáÂ∑≤Êõ¥Êñ∞‰∏∫: \(sampleRate) Hz")
                successCount += 1
            } else {
                print("‚ùå Êõ¥Êñ∞ MIDI ÈááÊ†∑ÁéáÂ§±Ë¥•")
                // Â∞ùËØïËé∑ÂèñËÆæÂ§áÊîØÊåÅÁöÑÈááÊ†∑ÁéáÂàóË°®
                printSupportedSampleRates(deviceID: deviceID)
            }
        } else {
            print("‚ÑπÔ∏è ÈááÊ†∑ÁéáÊó†ÈúÄÊõ¥Êîπ")
        }
        
        // ËÆæÁΩÆ‰ΩçÊ∑±Â∫¶
        if currentBitDepth != bitDepth {
            totalOperations += 1
            if setBitDepth(deviceID: deviceID, bitDepth: bitDepth) {
                print("‚úÖ MIDI ‰ΩçÊ∑±Â∫¶Â∑≤Êõ¥Êñ∞‰∏∫: \(bitDepth) bit")
                successCount += 1
            } else {
                print("‚ùå ËÆæÂ§á‰∏çÊîØÊåÅ \(bitDepth) bit ‰ΩçÊ∑±Â∫¶")
                printSupportedFormats(deviceID: deviceID)
            }
        } else {
            print("‚ÑπÔ∏è ‰ΩçÊ∑±Â∫¶Êó†ÈúÄÊõ¥Êîπ")
        }
        
        // ÂèëÈÄÅ MIDI Êó∂ÈíüÂêåÊ≠•Ê∂àÊÅØ
        sendMIDIClockSync(sampleRate: sampleRate)
        
        // ÊÄªÁªìÊìç‰ΩúÁªìÊûú
        if totalOperations > 0 {
            print("üìà Êìç‰ΩúÂÆåÊàê: \(successCount)/\(totalOperations) ÊàêÂäü")
        } else {
            print("‚ÑπÔ∏è ËÆæÂ§áËÆæÁΩÆÂ∑≤ÊòØÁõÆÊ†áÊ†ºÂºèÔºåÊó†ÈúÄÊõ¥Êîπ")
        }
    }
    
    private func printSupportedSampleRates(deviceID: AudioDeviceID) {
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyAvailableNominalSampleRates,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var size: UInt32 = 0
        var status = AudioObjectGetPropertyDataSize(deviceID, &address, 0, nil, &size)
        guard status == noErr else { return }
        
        let rangeCount = Int(size) / MemoryLayout<AudioValueRange>.size
        var ranges = Array<AudioValueRange>(repeating: AudioValueRange(), count: rangeCount)
        
        status = AudioObjectGetPropertyData(deviceID, &address, 0, nil, &size, &ranges)
        guard status == noErr else { return }
        
        print("üìã ËÆæÂ§áÊîØÊåÅÁöÑÈááÊ†∑ÁéáËåÉÂõ¥:")
        for range in ranges {
            if range.mMinimum == range.mMaximum {
                print("   - \(range.mMinimum) Hz")
            } else {
                print("   - \(range.mMinimum) - \(range.mMaximum) Hz")
            }
        }
    }
    
    private func printSupportedFormats(deviceID: AudioDeviceID) {
        print("üí° ÊèêÁ§∫: Êüê‰∫õËÆæÂ§áÂèØËÉΩ‰∏çÊîØÊåÅÂä®ÊÄÅ‰ΩçÊ∑±Â∫¶Êõ¥Êîπ")
        print("   Âª∫ËÆÆÂú® Audio MIDI Setup Â∫îÁî®‰∏≠ÊâãÂä®ÈÖçÁΩÆËÆæÂ§áÊ†ºÂºè")
    }
    
    private func setAudioDeviceSampleRate(deviceID: AudioDeviceID, sampleRate: Float64) -> Bool {
        // È¶ñÂÖàÊ£ÄÊü•ËÆæÂ§áÊòØÂê¶ÊîØÊåÅËØ•ÈááÊ†∑Áéá
        if !isSampleRateSupported(deviceID: deviceID, sampleRate: sampleRate) {
            print("‚ö†Ô∏è ËÆæÂ§á‰∏çÊîØÊåÅÈááÊ†∑Áéá \(sampleRate) Hz")
            return false
        }
        
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyNominalSampleRate,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var sampleRateValue = sampleRate
        
        // ÈáçËØïÊú∫Âà∂ÔºöÊúÄÂ§öÂ∞ùËØï3Ê¨°
        for attempt in 1...3 {
            let status = AudioObjectSetPropertyData(
                deviceID,
                &address,
                0,
                nil,
                UInt32(MemoryLayout<Float64>.size),
                &sampleRateValue
            )
            
            if status == noErr {
                // È™åËØÅËÆæÁΩÆÊòØÂê¶ÊàêÂäü
                Thread.sleep(forTimeInterval: 0.1) // Á≠âÂæÖËÆæÂ§áÂìçÂ∫î
                let actualRate = getCurrentSampleRate(deviceID: deviceID)
                if abs(actualRate - sampleRate) < 1.0 {
                    return true
                } else {
                    print("‚ö†Ô∏è ÈááÊ†∑ÁéáËÆæÁΩÆÈ™åËØÅÂ§±Ë¥•ÔºåÊúüÊúõ: \(sampleRate), ÂÆûÈôÖ: \(actualRate)")
                }
            } else {
                print("‚ö†Ô∏è ÈááÊ†∑ÁéáËÆæÁΩÆÂ§±Ë¥• (Â∞ùËØï \(attempt)/3)ÔºåÈîôËØØÁ†Å: \(status)")
                if attempt < 3 {
                    Thread.sleep(forTimeInterval: 0.2) // Á≠âÂæÖÂêéÈáçËØï
                }
            }
        }
        
        return false
    }
    
    private func isSampleRateSupported(deviceID: AudioDeviceID, sampleRate: Float64) -> Bool {
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyAvailableNominalSampleRates,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var size: UInt32 = 0
        var status = AudioObjectGetPropertyDataSize(deviceID, &address, 0, nil, &size)
        guard status == noErr else { return false }
        
        let rangeCount = Int(size) / MemoryLayout<AudioValueRange>.size
        var ranges = Array<AudioValueRange>(repeating: AudioValueRange(), count: rangeCount)
        
        status = AudioObjectGetPropertyData(deviceID, &address, 0, nil, &size, &ranges)
        guard status == noErr else { return false }
        
        for range in ranges {
            if sampleRate >= range.mMinimum && sampleRate <= range.mMaximum {
                return true
            }
        }
        
        return false
    }
    
    private func setBitDepth(deviceID: AudioDeviceID, bitDepth: Int) -> Bool {
        // Â∞ùËØïËÆæÁΩÆÈü≥È¢ëÊ†ºÂºè
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyStreamFormat,
            mScope: kAudioObjectPropertyScopeOutput,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var format = AudioStreamBasicDescription()
        var size = UInt32(MemoryLayout<AudioStreamBasicDescription>.size)
        
        // ÂÖàËé∑ÂèñÂΩìÂâçÊ†ºÂºè
        let getStatus = AudioObjectGetPropertyData(deviceID, &address, 0, nil, &size, &format)
        guard getStatus == noErr else { 
            print("‚ö†Ô∏è Êó†Ê≥ïËé∑ÂèñÂΩìÂâçÈü≥È¢ëÊ†ºÂºè")
            return false 
        }
        
        // Â§á‰ªΩÂéüÂßãÊ†ºÂºè
        var originalFormat = format
        
        // ‰øÆÊîπ‰ΩçÊ∑±Â∫¶
        switch bitDepth {
        case 16:
            format.mBitsPerChannel = 16
            format.mBytesPerFrame = UInt32(format.mChannelsPerFrame * 2)
            format.mBytesPerPacket = format.mBytesPerFrame
        case 24:
            format.mBitsPerChannel = 24
            format.mBytesPerFrame = UInt32(format.mChannelsPerFrame * 3)
            format.mBytesPerPacket = format.mBytesPerFrame
        case 32:
            format.mBitsPerChannel = 32
            format.mBytesPerFrame = UInt32(format.mChannelsPerFrame * 4)
            format.mBytesPerPacket = format.mBytesPerFrame
        default:
            print("‚ö†Ô∏è ‰∏çÊîØÊåÅÁöÑ‰ΩçÊ∑±Â∫¶: \(bitDepth)")
            return false
        }
        
        // ÈáçËØïÊú∫Âà∂ÔºöÊúÄÂ§öÂ∞ùËØï3Ê¨°
        for attempt in 1...3 {
            let setStatus = AudioObjectSetPropertyData(deviceID, &address, 0, nil, size, &format)
            
            if setStatus == noErr {
                // È™åËØÅËÆæÁΩÆÊòØÂê¶ÊàêÂäü
                Thread.sleep(forTimeInterval: 0.1)
                let actualBitDepth = getCurrentBitDepth(deviceID: deviceID)
                if actualBitDepth == bitDepth {
                    return true
                } else {
                    print("‚ö†Ô∏è ‰ΩçÊ∑±Â∫¶ËÆæÁΩÆÈ™åËØÅÂ§±Ë¥•ÔºåÊúüÊúõ: \(bitDepth), ÂÆûÈôÖ: \(actualBitDepth)")
                }
            } else {
                print("‚ö†Ô∏è ‰ΩçÊ∑±Â∫¶ËÆæÁΩÆÂ§±Ë¥• (Â∞ùËØï \(attempt)/3)ÔºåÈîôËØØÁ†Å: \(setStatus)")
                if attempt < 3 {
                    Thread.sleep(forTimeInterval: 0.2)
                }
            }
        }
        
        // Â¶ÇÊûúÊâÄÊúâÂ∞ùËØïÈÉΩÂ§±Ë¥•ÔºåÊÅ¢Â§çÂéüÂßãÊ†ºÂºè
        AudioObjectSetPropertyData(deviceID, &address, 0, nil, size, &originalFormat)
        return false
    }
    
    private func sendMIDIClockSync(sampleRate: Float64) {
        // ÂèëÈÄÅ MIDI Êó∂ÈíüÂêåÊ≠•Ê∂àÊÅØ
        let count = MIDIGetNumberOfDestinations()
        
        for i in 0..<count {
            let destination = MIDIGetDestination(i)
            
            // ÂèëÈÄÅÊó∂ÈíüÂêåÊ≠•Ê∂àÊÅØ (0xF8)
            var clockMessage: [UInt8] = [0xF8]
            var packetList = MIDIPacketList()
            var packet = MIDIPacketListInit(&packetList)
            
            packet = MIDIPacketListAdd(&packetList, 1024, packet, 0, 1, &clockMessage)
            
            // ÂèëÈÄÅ MIDI Ê∂àÊÅØ
            MIDISend(outputPort, destination, &packetList)
        }
        
        print("üïê MIDI Êó∂ÈíüÂêåÊ≠•Ê∂àÊÅØÂ∑≤ÂèëÈÄÅ")
    }
    
    private func cleanup() {
        timer?.invalidate()
        timer = nil
        
        if outputPort != 0 {
            MIDIPortDispose(outputPort)
        }
        if midiClient != 0 {
            MIDIClientDispose(midiClient)
        }
        
        print("üõë ÁõëÊéßÂ∑≤ÂÅúÊ≠¢")
    }
    
    func stop() {
        cleanup()
    }
}

// ‰∏ªÁ®ãÂ∫è
print("üéµ Apple Music MIDI ÊéßÂà∂Âô®ÂêØÂä®‰∏≠...")
let controller = AppleMusicMIDIController()

// ‰øùÊåÅÁ®ãÂ∫èËøêË°å
print("Êåâ Ctrl+C ÂÅúÊ≠¢ÁõëÊéß")
RunLoop.main.run()
